<a name="setup"><h1>Constructing a molecular system</h1></a>





<p>
The construction of a complete system for simulation or analysis
involves some or all of the following operations:
<ul>


<li> <p>
Creating molecules and other chemical objects.
</p>

<li> <p>
Defining the configuration of all objects.
</p>

<li> <p>
Defining the "surroundings" (e.g. boundary conditions).
</p>

<li> <p>
Choosing a force field.
</p>

</ul>

MMTK offers a large range of functions to deal with these tasks.
</p>



<hr width=70%>
<h2>Creating chemical objects</h2>





<p>
Chemical objects (atoms, molecules, complexes) are created from
definitions in the <a href="MMTK_8.html#database">database</a>. Since
these definitions contain most of the necessary information, the
subsequent creation of the objects is a simple procedure.
</p>



<p>
All objects are created by their class name
(<a href="MMTK_10.html#Class:MMTK.Atom">MMTK.Atom</a>, <a href="MMTK_10.html#Class:MMTK.Molecule">MMTK.Molecule</a>, and
<a href="MMTK_10.html#Class:MMTK.Complex">MMTK.Complex</a>) with the name
of the definition file as first parameter. Additional optional parameters
can be specified to modify the object being created. The following optional
parameters can be used for all object types:
<ul>


<li> <p>
 <tt>name=</tt>string
Specifies a name for the object. The default name is the one given in
the definition file.
</p>

<li> <p>
 <tt>position=</tt>vector
Specifies the position of the center of mass. The default is the origin.
</p>

<li> <p>
 <tt>configuration=</tt>string
Indicates a configuration from the configuration dictionary in the
definition file. The default is 'default' if such an entry exists in the
configuration dictionary. Otherwise the object is created without atomic
positions.
</p>

</ul>


</p>



<p>
Some examples with additional explanations for specific types:
<ul>


<li> <p>
 <tt>Atom('C')</tt> creates a carbon atom.
</p>

<li> <p>
 <tt>Molecule('water', position=Vector(0.,0.,1.))</tt>
creates a water molecule using configuration 'default' and moves the
center of mass to the indicated position.
</p>

</ul>


</p>



<h3>Proteins, peptide chains, and nucleotide chains</h3>





<p>
MMTK contains special support for working with proteins, peptide
chains, and nucleotide chains. As described in the chapter on the
<a href="MMTK_8.html#database">database</a>, proteins can be described by a special
database definition file. However, it is often simpler to create
protein objects directly in an application program. The classes
are <a href="MMTK_33.html#Class:MMTK.Proteins.PeptideChain">MMTK.Proteins.PeptideChain</a>,
<a href="MMTK_33.html#Class:MMTK.Proteins.Protein">MMTK.Proteins.Protein</a>,
and <a href="MMTK_30.html#Class:MMTK.NucleicAcids.NucleotideChain">MMTK.NucleicAcids.NucleotideChain</a>.
</p>



<p>
Proteins can be created from definition files in the database,
from previously constructed peptide chain objects, or directly
from PDB files if no special manipulations are necessary.
</p>



<p>
Examples: <tt>Protein('insulin')</tt> creates a
protein object for insulin from a database file.
<tt>Protein('1mbd.pdb')</tt> creates a protein
object for myoglobin directly from a PDB file, but leaving out the
heme group, which is not a peptide chain.
</p>



<p>
Peptide chains are created from a sequence of residues, which can be a
<a href="MMTK_31.html#Class:MMTK.PDB.PDBPeptideChain">MMTK.PDB.PDBPeptideChain</a> object, a list of three-letter
residue codes, or a string containing one-letter residue codes. In the
last two cases the atomic positions are not defined. MMTK provides
several models for the residues which provide different levels of
detail: an all-atom model, a model without hydrogen atoms, two models
containing only polar hydrogens (using different definitions of polar
hydrogens), and a model containing only the C-alpha atoms, with each
C-alpha atom having the mass of the entire residue. The last model
is useful for conformational analyses in which only the backbone
conformations are important.
</p>



<p>
The construction of nucleotide chains is very similar. The residue
list can be either a <a href="MMTK_31.html#Class:MMTK.PDB.PDBNucleotideChain">MMTK.PDB.PDBNucleotideChain</a> object or a list of
two-letter residue names. The first letter of a residue name indicates
the sugar type (<tt>'R'</tt> for ribose and
<tt>'D'</tt> for desoxyribose), and the second letter
defines the base (<tt>'A'</tt>, <tt>'C'</tt>, and
<tt>'G'</tt>, plus <tt>'T'</tt> for DNA and
<tt>'U'</tt> for RNA). The models are the same as for
peptide chains, except that the C-alpha model does not exist.
</p>



<p>
Most frequently proteins and nucleotide chains are created from a PDB
file. The PDB files often contain solvent (water) as well, and perhaps
some other molecules. MMTK provides convenient functions for extracting
information from PDB files and for building molecules from them in the
module <a href="MMTK_31.html#Module:MMTK.PDB">MMTK.PDB</a>. The first step is
the creation of a <a href="MMTK_31.html#Class:MMTK.PDB.PDBConfiguration">MMTK.PDB.PDBConfiguration</a>
object from the PDB file:
<pre>
from MMTK.PDB import PDBConfiguration
configuration = PDBConfiguration('some_file.pdb')
</pre>

The easiest way to generate MMTK objects for all molecules in the
PDB file is then
<pre>
molecules = configuration.createAll()
</pre>

The result is a collection of molecules, peptide chains, and
nucleotide chains, depending on the contents of the PDB files.
There are also methods for modifying the PDBConfiguration before
creating MMTK objects from it, and for creating objects
selectively. See the documentation for the modules
<a href="MMTK_31.html#Module:MMTK.PDB">MMTK.PDB</a> and Scientific.IO.PDB for details,
as well as the <a href="MMTK_42.html#Example:Proteins">protein</a> and 
<a href="MMTK_42.html#Example:DNA">DNA</a> examples.
</p>





<h3>Lattices</h3>





<p>
Sometimes it is necessary to generate objects (atoms or molecules)
positioned on a lattice. To facilitate this task, MMTK defines lattice
objects which are essentially sequence objects containing points or
objects at points. Lattices can therefore be used like lists with
indexing and <tt>for</tt>-loops. The lattice classes
are <a href="MMTK_26.html#Class:MMTK.Geometry.RhombicLattice">MMTK.Geometry.RhombicLattice</a>,
<a href="MMTK_26.html#Class:MMTK.Geometry.BravaisLattice">MMTK.Geometry.BravaisLattice</a>, and
<a href="MMTK_26.html#Class:MMTK.Geometry.SCLattice">MMTK.Geometry.SCLattice</a>.
</p>





<h3>Random numbers</h3>





<p>
The Python standard library and the Numerical Python package provide
random number generators, and more are available in seperate packages.
MMTK provides some convenience functions that return more specialized
random quantities: random points in a universe, random velocities,
random particle displacement vectors, random orientations. These
functions are defined in module <a href="MMTK_34.html#Module:MMTK.Random">MMTK.Random</a>.
</p>





<h3>Collections</h3>





<p>
Often it is useful to treat a collection of several objects as a
single entity.  Examples are a large number of solvent molecules
surrounding a solute, or all sidechains of a protein. MMTK has special
collection objects for this purpose, defined as class
<a href="MMTK_10.html#Class:MMTK.Collection">MMTK.Collection</a>. Most of the methods
available for molecules can also be used on collections.
</p>



<p>
A variant of a collection is the partitioned collection, implemented in
class <a href="MMTK_10.html#Class:MMTK.PartitionedCollection">MMTK.PartitionedCollection</a>. This class
acts much like a standard collection, but groups its elements by
geometrical position in small sub-boxes. As a consequence, some geometrical
algorithms (e.g. pair search within a cutoff) are much faster, but
other operations become somewhat slower.
</p>





<h3>Creating universes</h3>





<p>
A universe describes a complete molecular system consisting of any
number of chemical objects and a specification of their interactions
(i.e. a force field) and surroundings: boundary conditions, external
fields, thermostats, etc. The universe classes are defined in module
MMTK:
<ul>


<li> <p>

<a href="MMTK_10.html#Class:MMTK.InfiniteUniverse">MMTK.InfiniteUniverse</a> represents an infinite universe,
without any boundary or periodic boundary conditions.
</p>

<li> <p>

<a href="MMTK_10.html#Class:MMTK.OrthorhombicPeriodicUniverse">MMTK.OrthorhombicPeriodicUniverse</a> represents a periodic
universe with an orthorhombic elementary cell, whose size is defined
by the three edge lengths.
</p>

<li> <p>

<a href="MMTK_10.html#Class:MMTK.CubicPeriodicUniverse">MMTK.CubicPeriodicUniverse</a> is a special case
of <a href="MMTK_10.html#Class:MMTK.OrthorhombicPeriodicUniverse">MMTK.OrthorhombicPeriodicUniverse</a> in which the
elementary cell is cubic.
</p>

</ul>


</p>



<p>
Universes are created empty; the contents are then added to them.
Three types of objects can be added to a universe: chemical objects
(atoms, molecules, etc.), collections, and environment objects
(thermostats etc.). It is also possible to remove objects from a
universe.
</p>





<h3>Force fields</h3>





<p>
MMTK comes with several force fields, and permits the definition of
additional force fields. Force fields are defined in module <a href="MMTK_20.html#Module:MMTK.ForceFields">MMTK.ForceFields</a>. The most import built-in force
field is the <a href="http://www.amber.ucsf.edu/amber/amber.html">Amber 94 force field</a>,
represented by the class <a href="MMTK_20.html#Class:MMTK.ForceFields.Amber94ForceField">MMTK.ForceFields.Amber94ForceField</a>. It offers
several strategies for electrostatic interactions, including Ewald
summation, a fast multipole method [<a href="MMTK_44.html#Article:DPMTA">DPMTA</a>],
and cutoff with charge neutralization and optional screening [<a href="MMTK_44.html#Article:Wolf1999">Wolf1999</a>].
</p>



<p>
In addition to the Amber 94 force field, there is a Lennard-Jones
force field for noble gases (Class <a href="MMTK_20.html#Class:MMTK.ForceFields.LennardJonesForceField">MMTK.ForceFields.LennardJonesForceField</a>) and a
deformation force field for protein normal mode calculations (Class
<a href="MMTK_20.html#Class:MMTK.ForceFields.DeformationForceField">MMTK.ForceFields.DeformationForceField</a>).
</p>







<hr width=70%>
<h2>Referring to objects and parts of objects</h2>





<p>
Most MMTK objects (in fact all except for atoms) have a hierarchical
structure of parts of which they consist. For many operations it is
necessary to access specific parts in this hierarchy.
</p>



<p>
In most cases, parts are attributes with a specific name. For example,
the oxygen atom in every water molecule is an attribute with the name
"O". Therefore if <tt>w</tt> refers to a water
molecule, then <tt>w.O</tt> refers to its oxygen
atom. For a more complicated example, if <tt>m</tt>
refers to a molecule that has a methyl group called "M1", then <tt>m.M1.C</tt>
refers to the carbon atom of that methyl group. The names of attributes
are defined in the database.
</p>



<p>
Some objects consist of parts that need not have unique names, for
example the elements of a collection, the residues in a peptide chain,
or the chains in a protein. Such parts are accessed by indices; the
objects that contain them are Python sequence types. Some examples:
<ul>


<li> <p>
Asking for the number of items: if <tt>c</tt>
refers to a collection, then <tt>len(c)</tt> is
the number of its elements.
</p>

<li> <p>
Extracting an item: if <tt>p</tt> refers to a
protein, then <tt>p[0]</tt> is its first peptide
chain.
</p>

<li> <p>
Iterating over items: if <tt>p</tt> refers to a
peptide chain, then <tt>for residue in p: print
residue.position()</tt> will print the center of mass positions of
all its residues.
</p>

</ul>


</p>



<p>
Peptide and nucleotide chains also allow the operation of slicing: if <tt>p</tt>
refers to a peptide chain, then <tt>p[1:-1]</tt>
is a subchain extending from the second to the next-to-last residue.
</p>



<h3>The structure of peptide and nucleotide chains</h3>





<p>
Since peptide and nucleotide chains are not constructed from an explicit
definition file in the database, it is not evident where their
hierarchical structure comes from. But it is only the top-level
structure that is treated in a special way. The constituents of peptide
and nucleotide chains, residues, are normal group objects. The
definition files for these group objects are in the MMTK standard
database and can be freely inspected and even modified or overriden by
an entry in a database that is listed earlier in MMTKDATABASE.
</p>



<p>
Peptide chains are made up of amino acid residues, each of which is a
group consisting of two other groups, one being called "peptide" and the
other "sidechain". The first group contains the peptide group and the C
and H atoms; everything else is contained in the sidechain. The C atom
of the fifth residue of peptide chain <tt>p</tt>
is therefore referred to as <tt>p[4].peptide.C_alpha</tt>.
</p>



<p>
Nucleotide chains are made up of nucleotide residues, each of which is
a group consisting of two or three other groups. One group is called
"sugar" and is either a ribose or a desoxyribose group, the second one
is called "base" and is one the five standard bases. All but the first
residue in a nucleotide chain also have a subgroup called "phosphate"
describing the phosphate group that links neighbouring residues.
</p>







<hr width=70%>
<h2>Analyzing and modifying atom properties</h2>





<h3>General operations</h3>





<p>
Many inquiry and modification operations act at the atom level and
can equally well be applied to any object that is made up of
atoms, i.e. atoms, molecules, collections, universes, etc.
These operations are defined once in a <a href="MMTK_43.html#Glossary:MixInClass">mix-in class</a>
called <a href="MMTK_14.html#Class:MMTK.Collection.GroupOfAtoms">MMTK.Collection.GroupOfAtoms</a>, but are available
for all objects for which they make sense. They include inquiry-type
functions (total mass, center of mass, moment of inertia, bounding box,
total kinetic energy etc.), coordinate modifications (translation, rotation,
application of <a href="MMTK_3.html#transformation">transformation</a> objects) and coordinate
comparisons (RMS difference, optimal fits).
</p>





<a name="transformation"><h3>Coordinate transformations</h3><a>





<p>
The most common coordinate manipulations involve translations and
rotations of specific parts of a system. It is often useful to refer
to such an operation by a special kind of object, which permits the
combination and analysis of transformations as well as its application
to atomic positions.
</p>



<p>
Transformation objects specify a general displacement consisting of a
rotation around the origin of the coordinate system followed by a
translation. They are defined in the module Scientific.Geometry, but
for convenience the module MMTK contains a reference to them as well.
Transformation objects corresponding to pure translations can be
created with
<tt>Translation(</tt><i>displacement</i><tt>)</tt>;
transformation objects describing pure rotations with
<tt>Rotation(</tt><i>axis</i><tt>,
</tt><i>angle</i><tt>)</tt> or
<tt>Rotation(</tt><i>rotation</i><tt>_matrix)</tt>.
Multiplication of transformation objects returns a composite
transformation.
</p>



<p>
The translational component of any transformation can be obtained by
calling the method <tt>translation()</tt>; the
rotational component is obtained analogously with <tt>rotation()</tt>.
The displacement vector for a pure translation can be extracted with the
method <tt>displacement()</tt>, a tuple of axis
and angle can be extracted from a pure rotation by calling <tt>axisAndAngle()</tt>.
</p>





<a name="atom_property"><h3>Atomic property objects</h3><a>





<p>
Many properties in a molecular system are defined for each individual atom:
position, velocity, mass, etc. Such properties are represented in special
objects, defined in module MMTK: <a href="MMTK_10.html#Class:MMTK.ParticleScalar">MMTK.ParticleScalar</a>
for scalar quantities, <a href="MMTK_10.html#Class:MMTK.ParticleVector">MMTK.ParticleVector</a> for vector
quantities, and <a href="MMTK_10.html#Class:MMTK.ParticleTensor">MMTK.ParticleTensor</a> for rank-2 tensors.
All these objects can be indexed with an atom object to retrieve or change
the corresponding value. Standard arithmetic operations are also defined,
as well as some useful methods.
</p>





<a name="configuration"><h3>Configurations</h3><a>





<p>
A configuration object, represented by the class <a href="MMTK_10.html#Class:MMTK.Configuration">MMTK.Configuration</a> is a special variant of a
<a href="MMTK_10.html#Class:MMTK.ParticleVector">MMTK.ParticleVector</a> object. In addition to
the atomic coordinates of a universe, it stores geometric parameters
of a universe that are subject to change, e.g. the edge lengths
of the elementary cell of a periodic universe.
Every universe has a current configuration, which is what all operations
act on by default. It is also the configuration that is updated by
minimizations, molecular dynamics, etc. The current configuration can be
obtained by calling the method <tt>configuration()</tt>.
</p>



<p>
There are two ways to create configuration objects: by making a copy
of the current configuration (with
<tt>copy(universe.configuration())</tt>, or by reading a
configuration from a <a href="MMTK_4.html#trajectory">trajectory</a> file.
</p>







